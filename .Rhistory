plotseq = seq(1,length(Ftest),10)
par(mfrow = c(5,ceiling(length(plotseq)/5)),
mar = c(5,5,1.5,1.5))
for(j in plotseq){
plot(radj[,j,1], col = 'black',
type = 'l', ylim = c(0,800),
xlab = 'Iteration No.',ylab =  'R_eq')
text(x = maxiter*0.5, y = 600,
cex = 1.5, label = paste0('F = ',Ftest[j]))
## niter x fv x areas
for(i in 2:narea){
points(radj[,j,i], col = c('blue','red')[i-1], type = 'l')
}
}
plot.new()
legend('center',col = c('black','blue','red'),
legend = paste('Area',1:3), lty = 1, cex = 1.5)
## Rick's plots ----
p1 <- ggplot(current, aes(x = Fv, y = Yield)) +
geom_line(lwd = 1.1, aes(color = 'current')) +
geom_line(data = proposed, lwd = 1.1,linetype = 'dashed', aes(color = 'proposed')) +
scale_color_manual(values = c('seagreen','goldenrod')) +
theme_sleek() +theme(legend.position = 'none') #+ ggtitle("high oscillation problem -- conclude on 99th iteration")
p3 <- ggplot(current, aes(x = B, y = Yield)) +
geom_line(lwd = 1.1, aes(color = 'current')) +
geom_line(data = proposed, lwd = 1.1,linetype = 'dashed', aes(color = 'proposed')) +
scale_color_manual(values = c('seagreen','goldenrod')) +
labs(color = "Approach") +
theme_sleek() +theme(legend.position = c(0.8,0.8)) #+ ggtitle("high oscillation problem -- conclude on 99th iteration")
p1  | p3
## applying system-wide F
maxiter = 101
proposed <- data.frame(Fv = NA, Yield = NA, B = NA)
proposed_i <- array(NA, dim = c(length(Ftest),3,narea), dimnames = list(NULL,c('Fv','Yield',"B"))) ## now for each area
B_eq_i <- R_eq_i <- B_eq_i_INIT <- R_eq_i_INIT <- SB_Ri <- Yield_Ri <- matrix(NA, nrow =length(Ftest), ncol = narea)
radj <- array(NA, dim = c(maxiter,length(Ftest),3)) ## keeping track of convergence
testdf <- data.frame()
# for(v in 110:160){
for(v in 1:length(Ftest)){
# if(v %% 10 == 0) cat(v,"\n")
for(k in 1:maxiter){ ## Loop over steps A & B
testdf[k,'iter'] <- k
testdf[k,'F'] <- Ftest[v]
if(k == 1){
rdistUse <- recr_dist ## no distribution now; full rec-level in each area
rlevelUse = rec_level ## pre-specified No recruits in area, currently R0
} else{
rdistUse <- recr_dist ## only after computing R_i
rlevelUse =   list(rec_level,
rick[v,'R_ESUMB'],
rick[v,'R_SUMEBA'],
R_eq_i[v,],
R_eq_i[v,]*B_eq_i[v,]/sum(B_eq_i[v,]),
apply(rbind( R_eq_i[v,],radj[k-1,v,] ),2,mean),
rec_level*B_eq_i[v,]/sum(B_eq_i[v,]),
sum(R_eq_i[v,])*nominal_dist)[[4]]
}
testdf[k,'rec_a1'] <- rlevelUse[1]; testdf[k,'rec_a2'] <- rlevelUse[2] ; testdf[k,'rec_a3'] <- rlevelUse[3]
# radj[k,v,] <- rlevelUse
# if(k == 10  |k == 9 ) cat(v,"\t",k,"\t",paste(round(rlevelUse)),"\n") ## monitoring if this changes
## define virgin biomass by AREA
SB0_i <- doNage(Fv = rep(0,narea),
X = X_ija,
rdist = rdistUse,
refR = list(rec_level,rlevelUse)[[2]])$SB_i
## get values at present Fv
# In each iteration, calculate the SSB and Yield that
# comes from those recruits, taking movement into account
prop <- doNage( Fv = rep(Ftest[v],narea),
X = X_ija,
rdist = rdistUse,
refR = rlevelUse)
testdf[k,'B_a1'] <-     colSums(prop$B_ai)[1];
testdf[k,'B_a2'] <-     colSums(prop$B_ai)[2];
testdf[k,'B_a3'] <-     colSums(prop$B_ai)[3]
testdf[k,'Yield_a1'] <-     prop$Yield_i[1];
testdf[k,'Yield_a2'] <-    prop$Yield_i[2];
testdf[k,'Yield_a3'] <-     prop$Yield_i[3]
# radj[k,v,] <- rlevelUse
# call Equ_Spawn_Recr_Fxn for each area to get B_equil and R_equil from SPB/R and SR parms
for(i in 1:narea){ ## will overwrite second time
# calc area-specific SPB/R and Yield/R, using area-specific R
# if(length(rlevelUse) > 1 & k > 1){
if( k > 1){
rleveltmp = list(rlevelUse[i],
min(rlevelUse[i],R0[i]),
max(rlevelUse[i],R0[i]),
mean(c(rlevelUse[i],radj[k-1,v,i] )),
max(rlevelUse[i],1))[[1]]
#  if(rlevelUse[i] > R0[i]){
#    rleveltmp = R0[i]
#  } else if(rlevelUse[i] <1){
#    rleveltmp = 1
#  }
} else{
rleveltmp = rlevelUse[i]
}
# if(k %% 10 == 0 | k %% 3 == 0) cat(v, k,i,round(rleveltmp),"\n")
# cat(v, k,i,rlevelUse[i],radj[k-1,v,i] ,"\n")
cat(v, k,i,round(rleveltmp),"\n")
radj[k,v,i] <- rleveltmp
# if(round(prop$Yield_i[i],3) == 0) prop$Yield_i[i] <- 0
# prop$Yield_i[i] <- round(prop$Yield_i[i],3) ## avoid div by small numbers and get weirdstuff
# prop$SB_i[i] <- round(prop$SB_i[i],3) ## avoid div by small numbers and get weirdstuff
SB_Ri[v,i] <- prop$SB_i[i]/(rleveltmp*rdistUse[i]) ## on k = 1 will just be rleveltemp
Yield_Ri[v,i] <- prop$Yield_i[i]/(rleveltmp*rdistUse[i])
# if(k %% 10 == 0 ) cat(v, k,i,  Yield_Ri[v,i],"\n")
## Calc area-specific recruits using area-specific SB etc
# propEq <- Equil_Spawn_Recr_Fxn(steepness = steep[i], SSB_virgin = SB0_i[i],
#                                Recr_virgin = R0[i], SPR_temp = SB_Ri[v,i])
propEq <- Equil_Spawn_Recr_Fxn(steepness = steep[i], SSB_virgin = SB0_i[i],
Recr_virgin = R0[i], SPR_temp = SB_Ri[v,i])
B_eq_i[v,i] <- propEq$B_equil
R_eq_i[v,i] <- propEq$R_equil ## gets overwritten each iteration
if(k == maxiter){ ## store quantities
proposed_i[v,'Fv',i] <- Ftest[v]
proposed_i[v,'Yield',i] <-  Yield_Ri[v,i]*R_eq_i[v,i]
proposed_i[v,'B',i] <-    SB_Ri[v,i] *R_eq_i[v,i]
} ## end k max
} ## end areas
cat(v, k,i, Yield_Ri[v,i]*R_eq_i[v,i],"\n")
if(k == maxiter){ ## store quantities
## storing info, not currently used
rick[v,"Fv"] <- Ftest[v]
rick[v,"SBeqtotal"] <-   sum(B_eq_i[v,] )
## sum of expected recruits in areas
rick[v,"R_SUMEBA"]  <- sum( R_eq_i[v,])
}
} ## end k:maxiter
proposed[v,'Fv'] <- Ftest[v]
proposed[v,'Yield'] <-   sum(proposed_i[v,'Yield',])# sum(Yield_Ri[v,] * R_eq_i[v,]) # sum(Yield_Ri[v,]) * sum(R_eq_i[v,])
proposed[v,'B'] <-  sum(proposed_i[v,'B',])#sum(SB_Ri[v,] *  R_eq_i[v,i])  #sum(SB_Ri[v,]) * sum(B_eq_i[v,])
} ## end FV
a1 <- data.frame("Req" = R_eq_i[,1],"SBPR" = SB_Ri[,1],Ftest) %>%
ggplot(., aes(x = SBPR, y = Req, color = Ftest)) +
geom_point() + labs(color = 'F', title = 'Area 1') +
theme_sleek()+theme(legend.position = 'none')
a2 <- data.frame("Req" = R_eq_i[,2],"SBPR" = SB_Ri[,2],Ftest) %>%
ggplot(., aes(x = SBPR, y = Req, color = Ftest)) +
geom_point() + labs(color = 'F', title = 'Area 2') +
theme_sleek() +theme(legend.position = 'none')
a3 <- data.frame("Req" = R_eq_i[,3],"SBPR" = SB_Ri[,3],Ftest) %>%
ggplot(., aes(x = SBPR, y = Req, color = Ftest)) +
geom_point() +
labs(color = 'F', title = 'Area 3') +
theme_sleek()
a1 |a2 |a3
## SRR ----
bind_rows(rick %>%
select(Fv, SBeqtotal2, R_ESUMB) %>%
mutate(SB = SBeqtotal2, value =R_ESUMB,App = "R=E(sum(B_a)), current") %>%
select(Fv, SB, value, App),
rick %>%select(Fv, SBeqtotal, R_SUMEBA) %>%
mutate(SB = SBeqtotal, value =R_SUMEBA,App =  "R=sum(E(B_a)), proposed") %>%
select(Fv, SB, value, App)) %>%
# rick %>%
#   select(-Fv) %>%
#   melt(id = c('SBeqtotal', 'SBeqtotal2')) %>%
ggplot(., aes(x = SB, y = value, color = App)) +
geom_point(alpha = 0.2) +
theme_sleek() + theme(legend.position = c(0.75,0.1)) +
scale_color_manual(values = c('seagreen','goldenrod'))+
labs(x = "Total_SB", y = 'Recruitment', color = 'Approach')
Equil_Spawn_Recr_Fxn(steepness = steep[i], SSB_virgin = SB0_i[i],
Recr_virgin = R0[i], SPR_temp = 0.04[v,i])
head(R_eq_i)
R_eq_i[,1][R_eq_i[,1] < 1]
data.frame("Req" = R_eq_i[,1],"SBPR" = SB_Ri[,1],Ftest) %>% filter(SBPR < 0.04)
head(data.frame("Req" = R_eq_i[,1],"SBPR" = SB_Ri[,1],Ftest))
head(data.frame("Req" = R_eq_i[,2],"SBPR" = SB_Ri[,2],Ftest))
## SBPR vs R by FV----
a1 <- data.frame("Req" = R_eq_i[,1],"SBPR" = SB_Ri[,1],Ftest) %>%
ggplot(., aes(x = SBPR, y = Req, color = Ftest)) +
geom_point() + labs(color = 'F', title = 'Area 1') +
theme_sleek()+theme(legend.position = 'none')+
scale_y_continuous(limits = c(0,500))
a2 <- data.frame("Req" = R_eq_i[,2],"SBPR" = SB_Ri[,2],Ftest) %>%
ggplot(., aes(x = SBPR, y = Req, color = Ftest)) +
geom_point() + labs(color = 'F', title = 'Area 2') +
theme_sleek() +theme(legend.position = 'none')+
scale_y_continuous(limits = c(0,500))
a3 <- data.frame("Req" = R_eq_i[,3],"SBPR" = SB_Ri[,3],Ftest) %>%
ggplot(., aes(x = SBPR, y = Req, color = Ftest)) +
geom_point() +
labs(color = 'F', title = 'Area 3') +
theme_sleek() +
scale_y_continuous(limits = c(0,500))
a1 |a2 |a3
ggsave(last_plot(),
file = here('figs','ReqvsSBPR_F_area.png'),
width = 6, height = 4, unit = 'in', dpi = 520)
## applying system-wide F
maxiter = 101
proposed <- data.frame(Fv = NA, Yield = NA, B = NA)
proposed_i <- array(NA, dim = c(length(Ftest),3,narea), dimnames = list(NULL,c('Fv','Yield',"B"))) ## now for each area
B_eq_i <- R_eq_i <- B_eq_i_INIT <- R_eq_i_INIT <- SB_Ri <- Yield_Ri <- matrix(NA, nrow =length(Ftest), ncol = narea)
radj <- array(NA, dim = c(maxiter,length(Ftest),3)) ## keeping track of convergence
testdf <- data.frame()
for(v in 1:length(Ftest)){
for(k in 1:maxiter){ ## Loop over steps A & B
# testdf[k,'iter'] <- k
# testdf[k,'F'] <- Ftest[v]
if(k == 1){
rdistUse <- recr_dist ## no distribution now; full rec-level in each area
rlevelUse = rec_level ## pre-specified No recruits in area, currently R0
} else{
rdistUse <- recr_dist ## only after computing R_i
rlevelUse =   list(rec_level,
rick[v,'R_ESUMB'],
rick[v,'R_SUMEBA'],
R_eq_i[v,],
R_eq_i[v,]*B_eq_i[v,]/sum(B_eq_i[v,]),
apply(rbind( R_eq_i[v,],radj[k-1,v,] ),2,mean),
rec_level*B_eq_i[v,]/sum(B_eq_i[v,]),
sum(R_eq_i[v,])*nominal_dist)[[4]]
}
testdf[k,'rec_a1'] <- rlevelUse[1]; testdf[k,'rec_a2'] <- rlevelUse[2] ; testdf[k,'rec_a3'] <- rlevelUse[3]
## define virgin biomass by AREA
SB0_i <- doNage(Fv = rep(0,narea),
X = X_ija,
rdist = rdistUse,
refR = list(rec_level,rlevelUse)[[2]])$SB_i
## get values at present Fv
# In each iteration, calculate the SSB and Yield that
# comes from those recruits, taking movement into account
prop <- doNage( Fv = rep(Ftest[v],narea),
X = X_ija,
rdist = rdistUse,
refR = rlevelUse)
# testdf[k,'B_a1'] <-     colSums(prop$B_ai)[1];
# testdf[k,'B_a2'] <-     colSums(prop$B_ai)[2];
# testdf[k,'B_a3'] <-     colSums(prop$B_ai)[3]
# testdf[k,'Yield_a1'] <-     prop$Yield_i[1];
# testdf[k,'Yield_a2'] <-    prop$Yield_i[2];
# testdf[k,'Yield_a3'] <-     prop$Yield_i[3]
# call Equ_Spawn_Recr_Fxn for each area to get B_equil and R_equil from SPB/R and SR parms
for(i in 1:narea){ ## will overwrite second time
# calc area-specific SPB/R and Yield/R, using area-specific R
if( k > 1){
rleveltmp = list(rlevelUse[i],
min(rlevelUse[i],R0[i]),
max(rlevelUse[i],R0[i]),
mean(c(rlevelUse[i],radj[k-1,v,i] )),
max(rlevelUse[i],1))[[1]]
} else{
rleveltmp = rlevelUse[i]
}
cat(v, k,i,round(rleveltmp),"\n")
radj[k,v,i] <- rleveltmp
SB_Ri[v,i] <- prop$SB_i[i]/(rleveltmp*rdistUse[i]) ## on k = 1 will just be rleveltemp
Yield_Ri[v,i] <- prop$Yield_i[i]/(rleveltmp*rdistUse[i])
## Calc area-specific recruits using area-specific SB etc
propEq <- Equil_Spawn_Recr_Fxn(steepness = steep[i], SSB_virgin = SB0_i[i],
Recr_virgin = rleveltemp, SPR_temp = SB_Ri[v,i])
# propEq <- Equil_Spawn_Recr_Fxn(steepness = steep[i], SSB_virgin = SB0_i[i],
#                                Recr_virgin = R0[i], SPR_temp = SB_Ri[v,i])
B_eq_i[v,i] <- propEq$B_equil
R_eq_i[v,i] <- propEq$R_equil ## gets overwritten each iteration
if(k == maxiter){ ## store quantities
proposed_i[v,'Fv',i] <- Ftest[v]
proposed_i[v,'Yield',i] <-  Yield_Ri[v,i]*R_eq_i[v,i]
proposed_i[v,'B',i] <-    SB_Ri[v,i] *R_eq_i[v,i]
} ## end k max
} ## end areas
cat(v, k,i, Yield_Ri[v,i]*R_eq_i[v,i],"\n")
if(k == maxiter){ ## store quantities
## storing info, not currently used
rick[v,"Fv"] <- Ftest[v]
rick[v,"SBeqtotal"] <-   sum(B_eq_i[v,] )
## sum of expected recruits in areas
rick[v,"R_SUMEBA"]  <- sum( R_eq_i[v,])
}
} ## end k:maxiter
## save totals from final iteration
proposed[v,'Fv'] <- Ftest[v]
proposed[v,'Yield'] <-   sum(proposed_i[v,'Yield',])
proposed[v,'B'] <-  sum(proposed_i[v,'B',])
} ## end FV
for(v in 1:length(Ftest)){
for(k in 1:maxiter){ ## Loop over steps A & B
# testdf[k,'iter'] <- k
# testdf[k,'F'] <- Ftest[v]
if(k == 1){
rdistUse <- recr_dist ## no distribution now; full rec-level in each area
rlevelUse = rec_level ## pre-specified No recruits in area, currently R0
} else{
rdistUse <- recr_dist ## only after computing R_i
rlevelUse =   list(rec_level,
rick[v,'R_ESUMB'],
rick[v,'R_SUMEBA'],
R_eq_i[v,],
R_eq_i[v,]*B_eq_i[v,]/sum(B_eq_i[v,]),
apply(rbind( R_eq_i[v,],radj[k-1,v,] ),2,mean),
rec_level*B_eq_i[v,]/sum(B_eq_i[v,]),
sum(R_eq_i[v,])*nominal_dist)[[4]]
}
testdf[k,'rec_a1'] <- rlevelUse[1]; testdf[k,'rec_a2'] <- rlevelUse[2] ; testdf[k,'rec_a3'] <- rlevelUse[3]
## define virgin biomass by AREA
SB0_i <- doNage(Fv = rep(0,narea),
X = X_ija,
rdist = rdistUse,
refR = list(rec_level,rlevelUse)[[2]])$SB_i
## get values at present Fv
# In each iteration, calculate the SSB and Yield that
# comes from those recruits, taking movement into account
prop <- doNage( Fv = rep(Ftest[v],narea),
X = X_ija,
rdist = rdistUse,
refR = rlevelUse)
# testdf[k,'B_a1'] <-     colSums(prop$B_ai)[1];
# testdf[k,'B_a2'] <-     colSums(prop$B_ai)[2];
# testdf[k,'B_a3'] <-     colSums(prop$B_ai)[3]
# testdf[k,'Yield_a1'] <-     prop$Yield_i[1];
# testdf[k,'Yield_a2'] <-    prop$Yield_i[2];
# testdf[k,'Yield_a3'] <-     prop$Yield_i[3]
# call Equ_Spawn_Recr_Fxn for each area to get B_equil and R_equil from SPB/R and SR parms
for(i in 1:narea){ ## will overwrite second time
# calc area-specific SPB/R and Yield/R, using area-specific R
if( k > 1){
rleveltmp = list(rlevelUse[i],
min(rlevelUse[i],R0[i]),
max(rlevelUse[i],R0[i]),
mean(c(rlevelUse[i],radj[k-1,v,i] )),
max(rlevelUse[i],1))[[1]]
} else{
rleveltmp = rlevelUse[i]
}
cat(v, k,i,round(rleveltmp),"\n")
radj[k,v,i] <- rleveltmp
SB_Ri[v,i] <- prop$SB_i[i]/(rleveltmp*rdistUse[i]) ## on k = 1 will just be rleveltemp
Yield_Ri[v,i] <- prop$Yield_i[i]/(rleveltmp*rdistUse[i])
## Calc area-specific recruits using area-specific SB etc
propEq <- Equil_Spawn_Recr_Fxn(steepness = steep[i], SSB_virgin = SB0_i[i],
Recr_virgin = rleveltmp, SPR_temp = SB_Ri[v,i])
# propEq <- Equil_Spawn_Recr_Fxn(steepness = steep[i], SSB_virgin = SB0_i[i],
#                                Recr_virgin = R0[i], SPR_temp = SB_Ri[v,i])
B_eq_i[v,i] <- propEq$B_equil
R_eq_i[v,i] <- propEq$R_equil ## gets overwritten each iteration
if(k == maxiter){ ## store quantities
proposed_i[v,'Fv',i] <- Ftest[v]
proposed_i[v,'Yield',i] <-  Yield_Ri[v,i]*R_eq_i[v,i]
proposed_i[v,'B',i] <-    SB_Ri[v,i] *R_eq_i[v,i]
} ## end k max
} ## end areas
cat(v, k,i, Yield_Ri[v,i]*R_eq_i[v,i],"\n")
if(k == maxiter){ ## store quantities
## storing info, not currently used
rick[v,"Fv"] <- Ftest[v]
rick[v,"SBeqtotal"] <-   sum(B_eq_i[v,] )
## sum of expected recruits in areas
rick[v,"R_SUMEBA"]  <- sum( R_eq_i[v,])
}
} ## end k:maxiter
## save totals from final iteration
proposed[v,'Fv'] <- Ftest[v]
proposed[v,'Yield'] <-   sum(proposed_i[v,'Yield',])
proposed[v,'B'] <-  sum(proposed_i[v,'B',])
} ## end FV
## Rick's plots ----
p1 <- ggplot(current, aes(x = Fv, y = Yield)) +
geom_line(lwd = 1.1, aes(color = 'current')) +
geom_line(data = proposed, lwd = 1.1,linetype = 'dashed', aes(color = 'proposed')) +
scale_color_manual(values = c('seagreen','goldenrod')) +
theme_sleek() +theme(legend.position = 'none') #+ ggtitle("high oscillation problem -- conclude on 99th iteration")
p3 <- ggplot(current, aes(x = B, y = Yield)) +
geom_line(lwd = 1.1, aes(color = 'current')) +
geom_line(data = proposed, lwd = 1.1,linetype = 'dashed', aes(color = 'proposed')) +
scale_color_manual(values = c('seagreen','goldenrod')) +
labs(color = "Approach") +
theme_sleek() +theme(legend.position = c(0.8,0.8)) #+ ggtitle("high oscillation problem -- conclude on 99th iteration")
p1  | p3
doNage( Fv = rep(Ftest[1],narea),
X = X_ija,
rdist = rdistUse,
refR = rlevelUse)
data.frame("Req" = R_eq_i[,3],"SBPR" = SB_Ri[,3],Ftest) %>%
ggplot(., aes(x = SBPR, y = Req, color = Ftest)) +
geom_point() +
labs(color = 'F', title = 'Area 3') +
theme_sleek() +
geom_hline(R0[3], lwd = 1.1, color = 'red') +
scale_y_continuous(limits = c(0,500))
data.frame("Req" = R_eq_i[,3],"SBPR" = SB_Ri[,3],Ftest) %>%
ggplot(., aes(x = SBPR, y = Req, color = Ftest)) +
geom_point() +
labs(color = 'F', title = 'Area 3') +
theme_sleek() +
geom_hline(yintercept = R0[3], lwd = 1.1, color = 'red') +
scale_y_continuous(limits = c(0,500))
## applying system-wide F
maxiter = 101
proposed <- data.frame(Fv = NA, Yield = NA, B = NA)
proposed_i <- array(NA, dim = c(length(Ftest),3,narea), dimnames = list(NULL,c('Fv','Yield',"B"))) ## now for each area
B_eq_i <- R_eq_i <- B_eq_i_INIT <- R_eq_i_INIT <- SB_Ri <- Yield_Ri <- matrix(NA, nrow =length(Ftest), ncol = narea)
radj <- array(NA, dim = c(maxiter,length(Ftest),3)) ## keeping track of convergence
testdf <- data.frame()
for(v in 1:length(Ftest)){
for(k in 1:maxiter){ ## Loop over steps A & B
# testdf[k,'iter'] <- k
# testdf[k,'F'] <- Ftest[v]
if(k == 1){
rdistUse <- recr_dist ## no distribution now; full rec-level in each area
rlevelUse = rec_level ## pre-specified No recruits in area, currently R0
} else{
rdistUse <- recr_dist ## only after computing R_i
rlevelUse =   list(rec_level,
rick[v,'R_ESUMB'],
rick[v,'R_SUMEBA'],
R_eq_i[v,],
R_eq_i[v,]*B_eq_i[v,]/sum(B_eq_i[v,]),
apply(rbind( R_eq_i[v,],radj[k-1,v,] ),2,mean),
rec_level*B_eq_i[v,]/sum(B_eq_i[v,]),
sum(R_eq_i[v,])*nominal_dist)[[4]]
}
testdf[k,'rec_a1'] <- rlevelUse[1]; testdf[k,'rec_a2'] <- rlevelUse[2] ; testdf[k,'rec_a3'] <- rlevelUse[3]
## define virgin biomass by AREA
SB0_i <- doNage(Fv = rep(0,narea),
X = X_ija,
rdist = rdistUse,
refR = list(rec_level,rlevelUse)[[2]])$SB_i
## get values at present Fv
# In each iteration, calculate the SSB and Yield that
# comes from those recruits, taking movement into account
prop <- doNage( Fv = rep(Ftest[v],narea),
X = X_ija,
rdist = rdistUse,
refR = rlevelUse)
# testdf[k,'B_a1'] <-     colSums(prop$B_ai)[1];
# testdf[k,'B_a2'] <-     colSums(prop$B_ai)[2];
# testdf[k,'B_a3'] <-     colSums(prop$B_ai)[3]
# testdf[k,'Yield_a1'] <-     prop$Yield_i[1];
# testdf[k,'Yield_a2'] <-    prop$Yield_i[2];
# testdf[k,'Yield_a3'] <-     prop$Yield_i[3]
# call Equ_Spawn_Recr_Fxn for each area to get B_equil and R_equil from SPB/R and SR parms
for(i in 1:narea){ ## will overwrite second time
# calc area-specific SPB/R and Yield/R, using area-specific R
if( k > 1){
rleveltmp = list(rlevelUse[i],
min(rlevelUse[i],R0[i]),
max(rlevelUse[i],R0[i]),
mean(c(rlevelUse[i],radj[k-1,v,i] )),
max(rlevelUse[i],1))[[1]]
} else{
rleveltmp = rlevelUse[i]
}
cat(v, k,i,round(rleveltmp),"\n")
radj[k,v,i] <- rleveltmp
SB_Ri[v,i] <- prop$SB_i[i]/(rleveltmp*rdistUse[i]) ## on k = 1 will just be rleveltemp
Yield_Ri[v,i] <- prop$Yield_i[i]/(rleveltmp*rdistUse[i])
## Calc area-specific recruits using area-specific SB etc
# propEq <- Equil_Spawn_Recr_Fxn(steepness = steep[i], SSB_virgin = SB0_i[i],
# Recr_virgin = rleveltmp, SPR_temp = SB_Ri[v,i])
propEq <- Equil_Spawn_Recr_Fxn(steepness = steep[i], SSB_virgin = SB0_i[i],
Recr_virgin = R0[i], SPR_temp = SB_Ri[v,i])
B_eq_i[v,i] <- propEq$B_equil
R_eq_i[v,i] <- propEq$R_equil ## gets overwritten each iteration
if(k == maxiter){ ## store quantities
proposed_i[v,'Fv',i] <- Ftest[v]
proposed_i[v,'Yield',i] <-  Yield_Ri[v,i]*R_eq_i[v,i]
proposed_i[v,'B',i] <-    SB_Ri[v,i] *R_eq_i[v,i]
} ## end k max
} ## end areas
cat(v, k,i, Yield_Ri[v,i]*R_eq_i[v,i],"\n")
if(k == maxiter){ ## store quantities
## storing info, not currently used
rick[v,"Fv"] <- Ftest[v]
rick[v,"SBeqtotal"] <-   sum(B_eq_i[v,] )
## sum of expected recruits in areas
rick[v,"R_SUMEBA"]  <- sum( R_eq_i[v,])
}
} ## end k:maxiter
## save totals from final iteration
proposed[v,'Fv'] <- Ftest[v]
proposed[v,'Yield'] <-   sum(proposed_i[v,'Yield',])
proposed[v,'B'] <-  sum(proposed_i[v,'B',])
} ## end FV
a1 <- data.frame("Req" = R_eq_i[,1],"SBPR" = SB_Ri[,1],Ftest) %>%
ggplot(., aes(x = SBPR, y = Req, color = Ftest)) +
geom_point() + labs(color = 'F', title = 'Area 1') +
theme_sleek()+theme(legend.position = 'none')+
geom_hline(yintercept = R0[1], lwd = 1.1, color = 'red') +
scale_y_continuous(limits = c(0,500))
a2 <- data.frame("Req" = R_eq_i[,2],"SBPR" = SB_Ri[,2],Ftest) %>%
ggplot(., aes(x = SBPR, y = Req, color = Ftest)) +
geom_point() + labs(color = 'F', title = 'Area 2') +
theme_sleek() +theme(legend.position = 'none')+
geom_hline(yintercept = R0[2], lwd = 1.1, color = 'red') +
scale_y_continuous(limits = c(0,500))
a3 <- data.frame("Req" = R_eq_i[,3],"SBPR" = SB_Ri[,3],Ftest) %>%
ggplot(., aes(x = SBPR, y = Req, color = Ftest)) +
geom_point() +
labs(color = 'F', title = 'Area 3') +
theme_sleek() +
geom_hline(yintercept = R0[3], lwd = 1.1, color = 'red') +
scale_y_continuous(limits = c(0,500))
a1 |a2 |a3
ggsave(last_plot(),
file = here('figs','ReqvsSBPR_F_area.png'),
width = 6, height = 4, unit = 'in', dpi = 520)
## Rick's plots ----
p1 <- ggplot(current, aes(x = Fv, y = Yield)) +
geom_line(lwd = 1.1, aes(color = 'current')) +
geom_line(data = proposed, lwd = 1.1,linetype = 'dashed', aes(color = 'proposed')) +
scale_color_manual(values = c('seagreen','goldenrod')) +
theme_sleek() +theme(legend.position = 'none') #+ ggtitle("high oscillation problem -- conclude on 99th iteration")
p3 <- ggplot(current, aes(x = B, y = Yield)) +
geom_line(lwd = 1.1, aes(color = 'current')) +
geom_line(data = proposed, lwd = 1.1,linetype = 'dashed', aes(color = 'proposed')) +
scale_color_manual(values = c('seagreen','goldenrod')) +
labs(color = "Approach") +
theme_sleek() +theme(legend.position = c(0.8,0.8)) #+ ggtitle("high oscillation problem -- conclude on 99th iteration")
p1  | p3
