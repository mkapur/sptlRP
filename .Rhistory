proposed_i[v,'B',i] <-    SB_Ri[v,i] *R_eq_i[v,i]
# cat("B \t",v,k,i,  proposed_i[v,'B',i], "\n")
cat("Yield \t",v,k,i,  proposed_i[v,'B',i], "\n")
} ## end k max
} ## end areas
# cat("SB_i \t",v,k,i, prop$SB_i, "\n")
# cat("SBPR \t",v,k,i, SB_Ri[v,], "\n")
# cat("NEWREQ \t",v,k,i, R_eq_i[v,], "\n")
# cat("SB_i_ratio \t",v,k,i, prop$SB_i/sum(prop$SB_i), "\n")
# cat("NewREQ_ratio \t",v,k,i, R_eq_i[v,]/sum(R_eq_i[v,]), "\n")
# cat("SBPR_ratio \t",v,k,i, SB_Ri[v,]/sum(SB_Ri[v,]), "\n")
# if(k == maxiter){ ## store quantities
#   ## storing info, not currently used
#   rick[v,"Fv"] <- Ftest[v]
#   rick[v,"SBeqtotal"] <-   sum(B_eq_i[v,] )
#   ## sum of expected recruits in areas
#   rick[v,"R_SUMEBA"]  <- sum( R_eq_i[v,])
# }
} ## end k:maxiter
## save totals from final iteration
proposed[v,'Fv'] <- Ftest[v]
proposed[v,'Yield'] <-   sum(proposed_i[v,'Yield',])
proposed[v,'B'] <-  sum(proposed_i[v,'B',])
} ## end FV
rRef_proposed[,,RR] <- as.matrix(proposed)
rRef_proposed_i[,,,RR] <- proposed_i
} ## end RR
p1list = barlist=list()
for(i in 1:4){
current <- data.frame(rRef_current[,,i])
names(current) <- c('Fv','Yield','B')
proposed <-  data.frame(rRef_proposed[,,i])
names(proposed) <- c('Fv','Yield','B')
p1list[[i]] <- ggplot(current, aes(x = Fv, y = Yield)) +
geom_line(lwd = 1.1, aes(color = 'current')) +
geom_line(data = proposed, lwd = 1.1,linetype = 'dashed', aes(color = 'proposed')) +
scale_color_manual(values = c('seagreen','goldenrod')) +
labs(x = 'F', y = ifelse(i == 1, 'Yield',""), color = "") +
theme_sleek() +
theme(legend.position = if(i < 4) 'none' else c(0.8,0.8)) #+ ggtitle("high oscillation problem -- conclude on 99th iteration")
barlist[[i]] <- melt(data.frame(R0_list[[i]])) %>%
mutate(Area = 1:3) %>%
ggplot(., aes(x = Area, y = value, fill = factor(Area))) +
geom_histogram(stat = 'identity',
boundary = 0)+
scale_fill_grey()  +
annotate('text', x = 1:3, y = 200,
label = paste('Area',1:3),
color = c("grey88","grey33","grey22"), size = 3)+
scale_y_continuous(limits = c(0,500)) +
theme_void()+
theme(legend.position = 'none')
}
Rmisc::multiplot(plotlist = c(barlist,p1list),
layout = lay,
cols = 4)
plotseq = c(10:15)
par(mfrow = c(dim(rRef_proposed_radj)[4],length(plotseq)),
mar = c(5,5,1.5,1.5))
# plist = list()
for(i in 1:dim(rRef_proposed_radj)[4]){
radj <- rRef_proposed_radj[,,,i]
for(j in plotseq){
if(i == dim(rRef_proposed_radj)[4] & j == max(plotseq)) next()
plot(radj[,j,1], col = 'black',
type = 'l', ylim = c(0,800),
xlab = 'Iteration No.',
ylab =  'R_eq')
text(x = maxiter*0.5, y = 600,
cex = 1.5, label = paste0('F = ',Ftest[j]))
## niter x fv x areas
for(k in 2:narea){
lines(radj[,j,k], col = c('blue','red')[k-1])
}
} ## end j (Fs)
}
plot.new()
legend('center',
col = c('black','blue','red'),
legend = paste('Area',1:3), lty = 1, cex = 1)
rm(list = ls())
rm(list = ls())
## for running example
require(reshape)
require(dplyr, quietly = T)
require(here)
require(stats4)
## for plotting
require(patchwork)
require(ggsidekick)
require(ggplot2, quietly = T)
## settings ----
narea <- 3
nages <- 21
steep <- rep(0.7,3)
recr_dist <- c(1,1,1) ## global recruits to areas
R0_list <- list(c(420,330,250),
rev(c(420,330,250)),
c(333,333,333),
c(499,499,2)) #,
## load functions & initialize OM
lapply(list.files(here("R"), full.names = TRUE), source)
## Get NAA using movement. Input X_ija_NULL to turn movement OFF (smooth curve)
## applying system-wide F
Ftest <- seq(0,1,0.05)
rRef_current <- array(NA, dim = c(length(Ftest),3,length(R0_list)))
for(RR in 1:dim(rRef_current)[3]){
rec_level <- R0 <- R0_list[[RR]]
current <- data.frame(Fv = NA, Yield = NA, B = NA)
rick <- data.frame() ## storage for SRR question
for(v in 1:length(Ftest)){
rlevelUse = rec_level
## define virgin biomass
SB0 <- doNage( Fv = rep(0,narea),
X = X_ija,
rdist = recr_dist,
refR = rlevelUse)$SB_total
## get values at present Fv
curr <- doNage( Fv =  rep(Ftest[v],narea), #c(rep(Ftest[v],2),0), #
X = X_ija,
rdist = recr_dist, ## these are set to 1
refR = rlevelUse)
# calc SPB/R and Yield/R
SB_R <- curr$SB_total/sum(rlevelUse)
Yield_R <- curr$Yield_total/sum(rlevelUse)
#call Equil_Spawn_Recr_Fxn to get B_equil and R_equil from SPB/R and SR parms
currEq <- Equil_Spawn_Recr_Fxn(steepness = steep[1], SSB_virgin = SB0,
Recr_virgin = sum(R0), SPR_temp = SB_R)## L17247 ON TPL
if(currEq$R_equil > sum(R0)) currEq$R_equil <- sum(R0) ## could alternatively use flattop BH
current[v,'Fv'] <- Ftest[v]
current[v,'Yield'] <- Yield_R * currEq$R_equil
current[v,'B'] <- SB_R* currEq$R_equil ## the same as currEq$B_equil
rick[v,'R_ESUMB'] <- currEq$R_equil ## expected recruits given sum biomass in area
rick[v,'SBeqtotal2'] <- currEq$B_equil ## expected recruits given sum biomass in area
# } ## end iters
} ## end F
rRef_current[,,RR] <- as.matrix(current)
} ## end RefR
## applying system-wide F
maxiter = 101
rRef_proposed <- array(NA, dim = c(length(Ftest),3,length(R0_list)))
rRef_proposed_radj <- rRef_proposed_sbpr <- rRef_proposed_SBi <- array(NA, dim = c(maxiter,length(Ftest),narea,length(R0_list)))
rRef_proposed_i <- array(NA, dim = c(length(Ftest),3,narea,length(R0_list)))
for(RR in 1:dim(rRef_proposed)[3]){
rec_level <- R0 <- R0_list[[RR]]
proposed <- data.frame(Fv = NA, Yield = NA, B = NA)
proposed_i <- array(NA, dim = c(length(Ftest),3,narea), dimnames = list(NULL,c('Fv','Yield',"B"))) ## now for each area  ## define virgin biomass by AREA, does not change
B_eq_i <- R_eq_i <- B_eq_i_INIT <- R_eq_i_INIT <- SB_Ri <- Yield_Ri <- matrix(NA, nrow =length(Ftest), ncol = narea)
radj <- array(NA, dim = c(maxiter,length(Ftest),narea)) ## keeping track of convergence
SB0_i <- doNage(Fv = rep(0,narea),
X = X_ija,
rdist = recr_dist,
refR = rec_level)$SB_i
for(v in 1:length(Ftest)){
for(k in 1:maxiter){ ## Loop over steps A & B
if(k == 1){
rdistUse <- recr_dist ## no distribution now; full rec-level in each area
rlevelUse = rec_level ## pre-specified No recruits in area, currently R0
# SB_Ri3LAST  <- rec_level[3] ## not yet overwritten
} else{
rdistUse <- recr_dist ## only after computing R_i
rlevelUse =  R_eq_i[v,]# c(R_eq_i[v,1:2], max(1,round(R_eq_i[v,3],0)))
# SB_Ri3LAST  <- SB_Ri[v,3] ## not yet overwritten
}
cat("inreq \t",v,k,i, rlevelUse, "\n")
## get values at present Fv
# In each iteration, calculate the SSB and Yield that
# comes from those recruits, taking movement into account
prop <- doNage( Fv = rep(Ftest[v],narea), #c(rep(Ftest[v],2),0), #
X = X_ija,
rdist = rdistUse,
refR = rlevelUse)
# call Equ_Spawn_Recr_Fxn for each area to get B_equil and R_equil from SPB/R and SR parms
for(i in 1:narea){ ## will overwrite second time
# calc area-specific SPB/R and Yield/R, using area-specific R
if( k > 1){
rleveltmp = min(rlevelUse[i], R0[i])
} else{
rleveltmp = rlevelUse[i]
}
# if(round(rleveltmp) == 0) next() ## end iteration if rec is now zero
# cat(v, k,i,rleveltmp,"\n")
# radj[k,v,i] <- rleveltmp
rRef_proposed_radj[k,v,i,RR] <- rleveltmp
# SB_Ri[v,i] <- prop$SB_i[i]/(rleveltmp*rdistUse[i])## on k = 1 will just be rleveltemp
# SB_Ri[v,i] <- prop$SB_i[i]/(rleveltmp*rdistUse[i]) ## on k = 1 will just be rleveltemp
SB_Ri[v,i] <-  prop$SB_i[i]/((rleveltmp+0.005)*rdistUse[i]) ## Rick's idea
# if( SB_Ri[v,i] > SB0_i[i]) SB_Ri[v,i] <- SB0_i[i] ## penalty for dividing small numbers
# if(k > 2){
# SB_Ri[v,3] <- mean(rRef_proposed_sbpr[k-1,v,3,RR],
#                   prop$SB_i[i]/(rleveltmp*rdistUse[i]))
# SB_Ri[v,3] <- min(rRef_proposed_sbpr[k-1,v,3,RR],
#                   prop$SB_i[i]/(rleveltmp*rdistUse[i])) ## on k = 1 will just be rleveltemp
# }
Yield_Ri[v,i] <- prop$Yield_i[i]/(rleveltmp*rdistUse[i])
rRef_proposed_SBi[k,v,i,RR] <-  prop$SB_i[i]
rRef_proposed_sbpr[k,v,i,RR] <- SB_Ri[v,i]
# cat(v, k,i,    prop$SB_i[i],SB_Ri[v,i],"\n")
## Calc area-specific recruits using area-specific SB etc
propEq <- Equil_Spawn_Recr_Fxn(steepness = steep[i], SSB_virgin = SB0_i[i],
Recr_virgin = R0[i], SPR_temp = SB_Ri[v,i])
B_eq_i[v,i] <- propEq$B_equil
R_eq_i[v,i] <- propEq$R_equil ## gets overwritten each iteration
if(k == maxiter){ ## store quantities
proposed_i[v,'Fv',i] <- Ftest[v]
proposed_i[v,'Yield',i] <-  Yield_Ri[v,i]*R_eq_i[v,i]
proposed_i[v,'B',i] <-    SB_Ri[v,i] *R_eq_i[v,i]
# cat("B \t",v,k,i,  proposed_i[v,'B',i], "\n")
cat("Yield \t",v,k,i,  proposed_i[v,'B',i], "\n")
} ## end k max
} ## end areas
# cat("SB_i \t",v,k,i, prop$SB_i, "\n")
# cat("SBPR \t",v,k,i, SB_Ri[v,], "\n")
# cat("NEWREQ \t",v,k,i, R_eq_i[v,], "\n")
# cat("SB_i_ratio \t",v,k,i, prop$SB_i/sum(prop$SB_i), "\n")
# cat("NewREQ_ratio \t",v,k,i, R_eq_i[v,]/sum(R_eq_i[v,]), "\n")
# cat("SBPR_ratio \t",v,k,i, SB_Ri[v,]/sum(SB_Ri[v,]), "\n")
# if(k == maxiter){ ## store quantities
#   ## storing info, not currently used
#   rick[v,"Fv"] <- Ftest[v]
#   rick[v,"SBeqtotal"] <-   sum(B_eq_i[v,] )
#   ## sum of expected recruits in areas
#   rick[v,"R_SUMEBA"]  <- sum( R_eq_i[v,])
# }
} ## end k:maxiter
## save totals from final iteration
proposed[v,'Fv'] <- Ftest[v]
proposed[v,'Yield'] <-   sum(proposed_i[v,'Yield',])
proposed[v,'B'] <-  sum(proposed_i[v,'B',])
} ## end FV
rRef_proposed[,,RR] <- as.matrix(proposed)
rRef_proposed_i[,,,RR] <- proposed_i
} ## end RR
plotseq = c(10:15)
par(mfrow = c(dim(rRef_proposed_radj)[4],length(plotseq)),
mar = c(5,5,1.5,1.5))
# plist = list()
for(i in 1:dim(rRef_proposed_radj)[4]){
radj <- rRef_proposed_radj[,,,i]
for(j in plotseq){
if(i == dim(rRef_proposed_radj)[4] & j == max(plotseq)) next()
plot(radj[,j,1], col = 'black',
type = 'l', ylim = c(0,800),
xlab = 'Iteration No.',
ylab =  'R_eq')
text(x = maxiter*0.5, y = 600,
cex = 1.5, label = paste0('F = ',Ftest[j]))
## niter x fv x areas
for(k in 2:narea){
lines(radj[,j,k], col = c('blue','red')[k-1])
}
} ## end j (Fs)
}
plot.new()
legend('center',
col = c('black','blue','red'),
legend = paste('Area',1:3), lty = 1, cex = 1)
#   ## niter x fv x areas
#   for(i in 2:narea){
#     points(radj[,j,i], col = c('blue','red')[i-1], type = 'l')
#   }
# }
# plot.new()
# legend('center',col = c('black','blue','red'),
#        legend = paste('Area',1:3), lty = 1, cex = 1.5)
#
# dev.off()
png(here('figs','R_eq_iterations_v4_buffer.png'),
height = 8.5, width = 11, unit = 'in', res = 600)
plotseq = c(10:15)
par(mfrow = c(dim(rRef_proposed_radj)[4],length(plotseq)),
mar = c(5,5,1.5,1.5))
# plist = list()
for(i in 1:dim(rRef_proposed_radj)[4]){
radj <- rRef_proposed_radj[,,,i]
for(j in plotseq){
if(i == dim(rRef_proposed_radj)[4] & j == max(plotseq)) next()
plot(radj[,j,1], col = 'black',
type = 'l', ylim = c(0,800),
xlab = 'Iteration No.',
ylab =  'R_eq')
text(x = maxiter*0.5, y = 600,
cex = 1.5, label = paste0('F = ',Ftest[j]))
## niter x fv x areas
for(k in 2:narea){
lines(radj[,j,k], col = c('blue','red')[k-1])
}
} ## end j (Fs)
}
plot.new()
legend('center',
col = c('black','blue','red'),
legend = paste('Area',1:3), lty = 1, cex = 1)
dev.off()
p1list = barlist=list()
for(i in 1:4){
current <- data.frame(rRef_current[,,i])
names(current) <- c('Fv','Yield','B')
proposed <-  data.frame(rRef_proposed[,,i])
names(proposed) <- c('Fv','Yield','B')
p1list[[i]] <- ggplot(current, aes(x = Fv, y = Yield)) +
geom_line(lwd = 1.1, aes(color = 'current')) +
geom_line(data = proposed, lwd = 1.1,linetype = 'dashed', aes(color = 'proposed')) +
scale_color_manual(values = c('seagreen','goldenrod')) +
labs(x = 'F', y = ifelse(i == 1, 'Yield',""), color = "") +
theme_sleek() +
theme(legend.position = if(i < 4) 'none' else c(0.8,0.8)) #+ ggtitle("high oscillation problem -- conclude on 99th iteration")
barlist[[i]] <- melt(data.frame(R0_list[[i]])) %>%
mutate(Area = 1:3) %>%
ggplot(., aes(x = Area, y = value, fill = factor(Area))) +
geom_histogram(stat = 'identity',
boundary = 0)+
scale_fill_grey()  +
annotate('text', x = 1:3, y = 200,
label = paste('Area',1:3),
color = c("grey88","grey33","grey22"), size = 3)+
scale_y_continuous(limits = c(0,500)) +
theme_void()+
theme(legend.position = 'none')
}
lay = rbind(c(1,2,3,4),
c(5,6,7,8),
c(5,6,7,8))
Rmisc::multiplot(plotlist = c(barlist,p1list),
layout = lay,
cols = 4)
ggsave( Rmisc::multiplot(plotlist = c(barlist,p1list),
layout = lay,
cols = 4),
file = here('figs',"Yield_comparison_Rref_Buffer=0.005.png"),
width = 10, height = 8, unit = 'in', dpi = 420)
## Ricks plots by area ----
p1list = list()
blist= list()
for(i in 1:4){
proposed_i <-  rRef_proposed_i[,,,i]
propi1 <- data.frame(proposed_i[,1:3,1])
names(propi1) <- c('Fv','Yield','B')
propi2 <- data.frame(proposed_i[,1:3,2])
names(propi2) <- c('Fv','Yield','B')
propi3 <- data.frame(proposed_i[,1:3,3])
names(propi3) <- c('Fv','Yield','B')
p1list[[i]] <- ggplot( ) +
geom_line(data = propi1, lwd = 1.1,
aes(x = Fv, y = Yield, col = 'Area 1') ) +
geom_line(data = propi2, lwd = 1.1,
aes(x = Fv, y = Yield, col = 'Area 2') ) +
geom_line(data = propi3, lwd = 1.1,
aes(x = Fv, y = Yield, col = 'Area 3') ) +
labs(x = 'F', y = ifelse(i == 1, 'Yield',""), color = "") +
scale_color_grey() + scale_y_continuous(limits = c(0,65)) +
theme_sleek() +
theme(legend.position = if(i < 4) 'none' else c(0.8,0.8)) #+ ggtitle("high oscillation problem -- conclude on 99th iteration")
blist[[i]] <-  ggplot( ) +
geom_line(data = propi1, lwd = 1.1,
aes(x = Fv, y = B, col = 'Area 1') ) +
geom_line(data = propi2, lwd = 1.1,
aes(x = Fv, y = B, col = 'Area 2') ) +
geom_line(data = propi3, lwd = 1.1,
aes(x = Fv, y = B, col = 'Area 3') ) +
labs(x = 'F', y = ifelse(i == 1, 'B',""), color = "") +
scale_color_grey() +
scale_y_continuous(limits = c(0,625)) +
theme_sleek() +
theme(legend.position = if(i < 4) 'none' else c(0.7,0.8)) #+ ggtitle("high oscillation problem -- conclude on 99th iteration")
}
Rmisc::multiplot(plotlist = c(barlist,blist),
layout = lay,
cols = 4)
ggsave(  Rmisc::multiplot(plotlist = c(barlist,blist),
layout = lay,
cols = 4)
,
file = here('figs',"BvF_Area_Rref_Buffer=0.005.png"),
width = 10, height = 8, unit = 'in', dpi = 420)
Rmisc::multiplot(plotlist = c(barlist,p1list),
layout = lay,
cols = 4)
ggsave(  Rmisc::multiplot(plotlist = c(barlist,p1list),
layout = lay,
cols = 4)
,
file = here('figs',"YieldvF_Area_Rref_Buffer=0.005.png"),
width = 10, height = 8, unit = 'in', dpi = 420)
## applying system-wide F
maxiter = 101
rRef_proposed <- array(NA, dim = c(length(Ftest),3,length(R0_list)))
rRef_proposed_radj <- rRef_proposed_sbpr <- rRef_proposed_SBi <- array(NA, dim = c(maxiter,length(Ftest),narea,length(R0_list)))
rRef_proposed_i <- array(NA, dim = c(length(Ftest),3,narea,length(R0_list)))
for(RR in 1:dim(rRef_proposed)[3]){
rec_level <- R0 <- R0_list[[RR]]
proposed <- data.frame(Fv = NA, Yield = NA, B = NA)
proposed_i <- array(NA, dim = c(length(Ftest),3,narea), dimnames = list(NULL,c('Fv','Yield',"B"))) ## now for each area  ## define virgin biomass by AREA, does not change
B_eq_i <- R_eq_i <- B_eq_i_INIT <- R_eq_i_INIT <- SB_Ri <- Yield_Ri <- matrix(NA, nrow =length(Ftest), ncol = narea)
radj <- array(NA, dim = c(maxiter,length(Ftest),narea)) ## keeping track of convergence
SB0_i <- doNage(Fv = rep(0,narea),
X = X_ija,
rdist = recr_dist,
refR = rec_level)$SB_i
for(v in 1:length(Ftest)){
for(k in 1:maxiter){ ## Loop over steps A & B
if(k == 1){
rdistUse <- recr_dist ## no distribution now; full rec-level in each area
rlevelUse = rec_level ## pre-specified No recruits in area, currently R0
# SB_Ri3LAST  <- rec_level[3] ## not yet overwritten
} else{
rdistUse <- recr_dist ## only after computing R_i
rlevelUse =  R_eq_i[v,]# c(R_eq_i[v,1:2], max(1,round(R_eq_i[v,3],0)))
# SB_Ri3LAST  <- SB_Ri[v,3] ## not yet overwritten
}
cat("inreq \t",v,k,i, rlevelUse, "\n")
## get values at present Fv
# In each iteration, calculate the SSB and Yield that
# comes from those recruits, taking movement into account
prop <- doNage( Fv = rep(Ftest[v],narea), #c(rep(Ftest[v],2),0), #
X = X_ija,
rdist = rdistUse,
refR = rlevelUse)
# call Equ_Spawn_Recr_Fxn for each area to get B_equil and R_equil from SPB/R and SR parms
for(i in 1:narea){ ## will overwrite second time
# calc area-specific SPB/R and Yield/R, using area-specific R
if( k > 1){
rleveltmp = rlevelUse[i]#min(, R0[i])
} else{
rleveltmp = rlevelUse[i]
}
# if(round(rleveltmp) == 0) next() ## end iteration if rec is now zero
# cat(v, k,i,rleveltmp,"\n")
# radj[k,v,i] <- rleveltmp
rRef_proposed_radj[k,v,i,RR] <- rleveltmp
# SB_Ri[v,i] <- prop$SB_i[i]/(rleveltmp*rdistUse[i])## on k = 1 will just be rleveltemp
# SB_Ri[v,i] <- prop$SB_i[i]/(rleveltmp*rdistUse[i]) ## on k = 1 will just be rleveltemp
SB_Ri[v,i] <-  prop$SB_i[i]/((rleveltmp+0.005)*rdistUse[i]) ## Rick's idea
# if( SB_Ri[v,i] > SB0_i[i]) SB_Ri[v,i] <- SB0_i[i] ## penalty for dividing small numbers
# if(k > 2){
# SB_Ri[v,3] <- mean(rRef_proposed_sbpr[k-1,v,3,RR],
#                   prop$SB_i[i]/(rleveltmp*rdistUse[i]))
# SB_Ri[v,3] <- min(rRef_proposed_sbpr[k-1,v,3,RR],
#                   prop$SB_i[i]/(rleveltmp*rdistUse[i])) ## on k = 1 will just be rleveltemp
# }
Yield_Ri[v,i] <- prop$Yield_i[i]/(rleveltmp*rdistUse[i])
rRef_proposed_SBi[k,v,i,RR] <-  prop$SB_i[i]
rRef_proposed_sbpr[k,v,i,RR] <- SB_Ri[v,i]
# cat(v, k,i,    prop$SB_i[i],SB_Ri[v,i],"\n")
## Calc area-specific recruits using area-specific SB etc
propEq <- Equil_Spawn_Recr_Fxn(steepness = steep[i], SSB_virgin = SB0_i[i],
Recr_virgin = R0[i], SPR_temp = SB_Ri[v,i])
B_eq_i[v,i] <- propEq$B_equil
R_eq_i[v,i] <- propEq$R_equil ## gets overwritten each iteration
if(k == maxiter){ ## store quantities
proposed_i[v,'Fv',i] <- Ftest[v]
proposed_i[v,'Yield',i] <-  Yield_Ri[v,i]*R_eq_i[v,i]
proposed_i[v,'B',i] <-    SB_Ri[v,i] *R_eq_i[v,i]
# cat("B \t",v,k,i,  proposed_i[v,'B',i], "\n")
cat("Yield \t",v,k,i,  proposed_i[v,'B',i], "\n")
} ## end k max
} ## end areas
# cat("SB_i \t",v,k,i, prop$SB_i, "\n")
# cat("SBPR \t",v,k,i, SB_Ri[v,], "\n")
# cat("NEWREQ \t",v,k,i, R_eq_i[v,], "\n")
# cat("SB_i_ratio \t",v,k,i, prop$SB_i/sum(prop$SB_i), "\n")
# cat("NewREQ_ratio \t",v,k,i, R_eq_i[v,]/sum(R_eq_i[v,]), "\n")
# cat("SBPR_ratio \t",v,k,i, SB_Ri[v,]/sum(SB_Ri[v,]), "\n")
# if(k == maxiter){ ## store quantities
#   ## storing info, not currently used
#   rick[v,"Fv"] <- Ftest[v]
#   rick[v,"SBeqtotal"] <-   sum(B_eq_i[v,] )
#   ## sum of expected recruits in areas
#   rick[v,"R_SUMEBA"]  <- sum( R_eq_i[v,])
# }
} ## end k:maxiter
## save totals from final iteration
proposed[v,'Fv'] <- Ftest[v]
proposed[v,'Yield'] <-   sum(proposed_i[v,'Yield',])
proposed[v,'B'] <-  sum(proposed_i[v,'B',])
} ## end FV
rRef_proposed[,,RR] <- as.matrix(proposed)
rRef_proposed_i[,,,RR] <- proposed_i
} ## end RR
plotseq = c(10:15)
par(mfrow = c(dim(rRef_proposed_radj)[4],length(plotseq)),
mar = c(5,5,1.5,1.5))
# plist = list()
for(i in 1:dim(rRef_proposed_radj)[4]){
radj <- rRef_proposed_radj[,,,i]
for(j in plotseq){
if(i == dim(rRef_proposed_radj)[4] & j == max(plotseq)) next()
plot(radj[,j,1], col = 'black',
type = 'l', ylim = c(0,800),
xlab = 'Iteration No.',
ylab =  'R_eq')
text(x = maxiter*0.5, y = 600,
cex = 1.5, label = paste0('F = ',Ftest[j]))
## niter x fv x areas
for(k in 2:narea){
lines(radj[,j,k], col = c('blue','red')[k-1])
}
} ## end j (Fs)
}
plot.new()
legend('center',
col = c('black','blue','red'),
legend = paste('Area',1:3), lty = 1, cex = 1)
max(Radj[,13,3,2])
max(radj[,13,3,2])
max(rRef_proposed_radj[,13,3,2])
max(rRef_proposed_radj[,13,3,1])
max(rRef_proposed_radj[,13,3,3])
max(rRef_proposed_radj[,13,3,3])/R0_list[[3]][3]
max(rRef_proposed_radj[,13,3,2])/R0_list[[2]][3]
max(rRef_proposed_radj[,13,3,1])/R0_list[[1]][3]
max(rRef_proposed_radj[,13,3,4])/R0_list[[4]][3]
