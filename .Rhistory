#   ggplot(., aes(x = (FF_Area1), y = tyield)) +
#   geom_point()
#
# data.frame(surface[,,'local']) %>%
#   filter(FF_Area2 == 1.0) %>%
#   ggplot(., aes(x = (FF_Area1), y = tyield)) +
#   geom_point()
## make results table ----
data.frame(scen) %>%
mutate(WA = "Linear increasing function; identical between areas") %>%
mutate(
NATM,
'GLOBAL_FMSY_A1' = FMSY_GLOBAL_A1,
'LOCAL_FMSY_A1' = FMSY_LOCAL_A1,
'GLOBAL_FMSY_A2' = FMSY_GLOBAL_A2,
'LOCAL_FMSY_A2'= FMSY_LOCAL_A2,
'GLOBALFMSY' = paste(round(GLOBAL_FMSY_A1,2),round(GLOBAL_FMSY_A2,2), sep = ", "),
'LOCALFMSY' = paste(round(LOCAL_FMSY_A1,2),round(LOCAL_FMSY_A2,2), sep = ", "),
'MSY_RATIO' =  round(as.numeric(MSY_GLOBAL)/as.numeric(MSY_LOCAL),2),
'GLOBAL_SBMSY' = round(as.numeric(SBMSY_GLOBAL),2),
'LOCAL_SBMSY' = as.numeric(SBMSY_LOCAL),
'SBMSY_RATIO' = round(GLOBAL_SBMSY/LOCAL_SBMSY,2),
'SBMSY_A1_RATIO' = round(as.numeric(SBMSY_A1_RATIO),2),
'SBMSY_A2_RATIO' = round(as.numeric(SBMSY_A2_RATIO),2),
'GLOBAL_SB0' = as.numeric(A1SB0_GLOBAL)+as.numeric(A2SB0_GLOBAL),
'LOCAL_SB0' = as.numeric(A1SB0_LOCAL)+as.numeric(A2SB0_LOCAL),
'GLOBAL_DEPL_TOTAL' = round(GLOBAL_SBMSY/GLOBAL_SB0,2),
'LOCAL_DEPL_TOTAL' = round(LOCAL_SBMSY/LOCAL_SB0,2),
'WAA' = 'Fig. 1A',
'SteepnessH' =  paste(H1,H2,sep = ", "),
'Movement' = ifelse(PSTAY_A2 == 1,
'Fig. 1D',
ifelse(PSTAY_A2 == 0.75,
"Fig. 1C",
"Fig. 1E")),
'Selectivity' = ifelse(SLX_A50_A1  == 9, 'Fig. 1F',
ifelse(SLX_A50_A1  ==7, "Fig. 1G","Fig. 1H"))) %>%
select('Scenario' = SCENARIO_NAME,
'PropR' = PROPR,
'Natural Mortality M' = NATM,
'Weight at Age' = WAA,
Movement, Selectivity,
SteepnessH,
GLOBALFMSY,
LOCALFMSY,
SBMSY_RATIO_TOTAL =SBMSY_RATIO,
# SBMSY_A1_RATIO,
# SBMSY_A2_RATIO,
MSY_RATIO,
GLOBAL_DEPL_TOTAL,
LOCAL_DEPL_TOTAL) %>%
# View()
write.csv(., file = here('output',paste0(Sys.Date(),'-results.csv')), row.names = FALSE)
head(scen)
View(scen)
s = 10
# for(s in c(1:5)){
#* build dat ----
SCENARIO = scen[s,'SCENARIO_NAME']
steeps <- c(scen[s,'H1'], scen[s,'H2'])
pStayt <- as.numeric(c(scen[s,'PSTAY_A1'],scen[s,'PSTAY_A2']))
if(length(grep('WAA', SCENARIO)) == 0 ){
dat <- makeDat(wa = NULL, ## default wa
mort = scen[s,'NATM'],
h = steeps,
input_prop = scen[s,'PROPR'],
fec_a50 = c(6,6),
fec_a95 = c(12,12),
slx_a50= c(as.numeric(scen[s,'SLX_A50_A1']),9),
slx_a95= c(as.numeric(scen[s,'SLX_A95_A1']),13),
pStay=pStayt)
} else{
dat <- makeDat(wa = "NOTNULL",
mort = scen[s,'NATM'],
h = steeps,
input_prop = scen[s,'PROPR'],
fec_a50 = c(6,6),
fec_a95 = c(12,12),
slx_a50= c(as.numeric(scen[s,'SLX_A50_A1']),9),
slx_a95= c(as.numeric(scen[s,'SLX_A95_A1']),13),
pStay=pStayt)
}
F1 = F2 = 0.4
WAA <-  matrix(c(dat$dat[Ages+1,'weight',1], dat$dat[Ages+1,'weight',2]),nrow=2,ncol=Nages, byrow = T)
Sel <- matrix(c(dat$dat[Ages+1,'fishery_selectivity',1], dat$dat[Ages+1,'fishery_selectivity',2]),nrow=2,ncol=Nages, byrow = T)
Fec <- matrix(c(Sel[1,]*WAA[1,], Sel[2,]*WAA[2,]),nrow=2,ncol=Nages, byrow = T)
N_F0 <- doNAA(F1=0,F2=0, usedat =dat, Sel)$N
N_Z_F <- doNAA(F1, F2, usedat = dat, Sel)
## derived quants on a per-area basis
## these are per one recruit (no prop here)
SBPR <- SBPF0 <- Cat <- c(0,0)
Cat <- matrix(0,nrow=2,ncol=2)
for(area in 1:2){
for (Iage in 1:Nages) SBPF0[area] <- SBPF0[area] + Fec[area,Iage]*sum(N_F0[area,Iage,1:2])
for (Iage in 1:Nages) Cat[area,1] <- Cat[area,1] + WAA[area,Iage]*Sel[area,Iage]*c(F1,F2)[area]*sum(N_Z_F$N[area,Iage,1])/
N_Z_F$Z[area,Iage]*(1.0-exp(-N_Z_F$Z[area,Iage]))
for (Iage in 1:Nages) Cat[area,2] <- Cat[area,2] + WAA[area,Iage]*Sel[area,Iage]*c(F1,F2)[area]*sum(N_Z_F$N[area,Iage,2])/
N_Z_F$Z[area,Iage]*(1.0-exp(-N_Z_F$Z[area,Iage]))
for (Iage in 1:Nages) SBPR[area] <- SBPR[area] + Fec[area,Iage]*sum(N_Z_F$N[area,Iage,1:2]) ## does NOT have prop
}
optimFunc <- function(par,Fec,N_F0,N_Z_F){
# cat(par,"\n")
cat(dat$h,"\n")
passR <- par[1]; passRprop <- par[2]
#print(passR)
#print(passRprop)
sb_F <- sb_0 <- Cat <- c(0,0)
PropF0 = dat$input_prop
RecF0 = GLOBAL_R0
Nages <- 20
for(area in 1:2){
for (Iage in 1:Nages) sb_0[area] <- sb_0[area] + RecF0*Fec[area,Iage]*(PropF0*N_F0[area,Iage,1]+(1-PropF0)*N_F0[area,Iage,2])
for (Iage in 1:Nages) sb_F[area] <- sb_F[area] + passR*Fec[area,Iage]*(passRprop*N_Z_F[area,Iage,1]+(1-passRprop)*N_Z_F[area,Iage,2])
}
Rexp = c(0,0)
for(i in 1:narea){
if(i == 1){
num <- GLOBAL_R0*passRprop*4*dat$h[[i]]*sb_F[[i]]/sb_0[[i]]
} else{
num <- GLOBAL_R0*(1-passRprop)*4*dat$h[[i]]*sb_F[[i]]/sb_0[[i]]
}
denom1 <- sb_F[[i]]/sb_0[[i]]*(5*dat$h[[i]]-1)
denom2 <- (1-dat$h[[i]])
Rexp[i] = num/(denom1+denom2)
} ## end area loop
obsR <- passR*c(passRprop,1-passRprop)
#cat(obsR,"\n")
#cat(Rexp,'\n')
obj <- sum((obsR - Rexp)^2)
#cat(passR,passRprop,obj,"\n")
return(obj)
}
getEqR <- function(assumption = 'GLOBAL', Fec, N_F0, N_Z_F, Prop, Steep){
if(assumption == 'GLOBAL'){
# use summed qtties and return straight up req
# Top <- 4*GLOBAL_R0*Steep*SSB/SBPF0 - (1-Steep)
# Bot <- (5*Steep-1)*SSB/SBPF0
# Recr <- Top/Bot
# return(max(1e-4,Recr))
cat(Steep,"\n")
SBPR <- SBPF0 <- Cat <- c(0,0)
Nages <- 20
for(area in 1:2){
for (Iage in 1:Nages) SBPF0[area] <- SBPF0[area] + Fec[area,Iage]*(Prop*N_F0[area,Iage,1]+(1-Prop)*N_F0[area,Iage,2])
for (Iage in 1:Nages) SBPR[area] <- SBPR[area] + Fec[area,Iage]*(Prop*N_Z_F[area,Iage,1]+(1-Prop)*N_Z_F[area,Iage,2])
}
SBPF0 <- sum(SBPF0)
SSB  <- sum(SBPR)
alpha = SBPF0*(1-Steep)/(4*Steep)
beta = (5*Steep-1)/(4*Steep*GLOBAL_R0)
req <- max(0.001, (SSB - alpha)/(beta*SSB)) ## a la SS
#cat("LocalR",req,"\n")
} else{
## raw calc
# Recr <- c(0,0)
# for(i in 1:2){
#   Top <- 4*Steep[i]*SSB[i]/SBPF0[i] - (1-Steep[i])
#   Bot <- (5*Steep[i]-1)*SSB[i]/SBPF0[i]
#   Recr[i] <- max(1e-4,Top/Bot)
# }
#
# return(Recr)
## optimize
opt_temp <- optim(par = c(1,Prop),
Fec = Fec,
N_F0 = N_F0,
N_Z_F = N_Z_F,
lower = c(1E-4,1E-4),
upper = c(NA,1-1E-5),
method = "L-BFGS-B",
fn = optimFunc, hessian = FALSE,
control = list(
maxit = 1000,
ndeps = rep(1e-4,2)))
return(opt_temp)
}
}
## derived quants on a per-area basis
## these are per one recruit (no prop here)
SBPR <- SBPF0 <- Cat <- c(0,0)
Cat <- matrix(0,nrow=2,ncol=2)
for(area in 1:2){
for (Iage in 1:Nages) SBPF0[area] <- SBPF0[area] + Fec[area,Iage]*sum(N_F0[area,Iage,1:2])
for (Iage in 1:Nages) Cat[area,1] <- Cat[area,1] + WAA[area,Iage]*Sel[area,Iage]*c(F1,F2)[area]*sum(N_Z_F$N[area,Iage,1])/
N_Z_F$Z[area,Iage]*(1.0-exp(-N_Z_F$Z[area,Iage]))
for (Iage in 1:Nages) Cat[area,2] <- Cat[area,2] + WAA[area,Iage]*Sel[area,Iage]*c(F1,F2)[area]*sum(N_Z_F$N[area,Iage,2])/
N_Z_F$Z[area,Iage]*(1.0-exp(-N_Z_F$Z[area,Iage]))
for (Iage in 1:Nages) SBPR[area] <- SBPR[area] + Fec[area,Iage]*sum(N_Z_F$N[area,Iage,1:2]) ## does NOT have prop
}
req_global <- getEqR(assumption = 'GLOBAL',
Fec = Fec,
N_F0 = N_F0,
N_Z_F = N_Z_F$N,
Prop=dat$input_prop,
Steep = mean(dat$h))
req_local <- getEqR(assumption = 'LOCAL',
Fec = Fec,
N_F0 = N_F0,
N_Z_F = N_Z_F$N,
Prop=dat$input_prop,
Steep = dat$h)
dat$h
dat$h[[i]]
i = 1
i = 1
dat$h[[i]]
dat$h[[2]]
class(dat)
class(dat$h)
dat$h[1]
dat$h[2]
optimFunc <- function(par,Fec,N_F0,N_Z_F){
# cat(par,"\n")
cat(dat$h,"\n")
passR <- par[1]; passRprop <- par[2]
#print(passR)
#print(passRprop)
sb_F <- sb_0 <- Cat <- c(0,0)
PropF0 = dat$input_prop
RecF0 = GLOBAL_R0
Nages <- 20
for(area in 1:2){
for (Iage in 1:Nages) sb_0[area] <- sb_0[area] + RecF0*Fec[area,Iage]*(PropF0*N_F0[area,Iage,1]+(1-PropF0)*N_F0[area,Iage,2])
for (Iage in 1:Nages) sb_F[area] <- sb_F[area] + passR*Fec[area,Iage]*(passRprop*N_Z_F[area,Iage,1]+(1-passRprop)*N_Z_F[area,Iage,2])
}
Rexp = c(0,0)
for(i in 1:narea){
if(i == 1){
num <- GLOBAL_R0*passRprop*4*dat$h[i]*sb_F[[i]]/sb_0[[i]]
} else{
num <- GLOBAL_R0*(1-passRprop)*4*dat$h[i]*sb_F[[i]]/sb_0[[i]]
}
denom1 <- sb_F[[i]]/sb_0[[i]]*(5*dat$h[i]-1)
denom2 <- (1-dat$h[i])
Rexp[i] = num/(denom1+denom2)
} ## end area loop
obsR <- passR*c(passRprop,1-passRprop)
#cat(obsR,"\n")
#cat(Rexp,'\n')
obj <- sum((obsR - Rexp)^2)
#cat(passR,passRprop,obj,"\n")
return(obj)
}
req_global <- getEqR(assumption = 'GLOBAL',
Fec = Fec,
N_F0 = N_F0,
N_Z_F = N_Z_F$N,
Prop=dat$input_prop,
Steep = mean(dat$h))
req_local <- getEqR(assumption = 'LOCAL',
Fec = Fec,
N_F0 = N_F0,
N_Z_F = N_Z_F$N,
Prop=dat$input_prop,
Steep = dat$h)
dat$h = c(0.7,0.7)
steeps = 0.7
req_global <- getEqR(assumption = 'GLOBAL',
Fec = Fec,
N_F0 = N_F0,
N_Z_F = N_Z_F$N,
Prop=dat$input_prop,
Steep = mean(dat$h))
req_local <- getEqR(assumption = 'LOCAL',
Fec = Fec,
N_F0 = N_F0,
N_Z_F = N_Z_F$N,
Prop=dat$input_prop,
Steep = dat$h)
req_global
req_local
Recr_global = c(req_global*dat$input_prop,req_global*(1-dat$input_prop))
Recr_local <- c(req_local$par[1]*req_local$par[2],req_local$par[1]*(1-req_local$par[2]))
Recr_local
Recr_global
dat$h = c(0.7,0.75)
req_global <- getEqR(assumption = 'GLOBAL',
Fec = Fec,
N_F0 = N_F0,
N_Z_F = N_Z_F$N,
Prop=dat$input_prop,
Steep = mean(dat$h))
req_local <- getEqR(assumption = 'LOCAL',
Fec = Fec,
N_F0 = N_F0,
N_Z_F = N_Z_F$N,
Prop=dat$input_prop,
Steep = dat$h)
Recr_global = c(req_global*dat$input_prop,req_global*(1-dat$input_prop))
Recr_local <- c(req_local$par[1]*req_local$par[2],req_local$par[1]*(1-req_local$par[2]))
#print(Cat)
print(Recr_global)
print(Recr_local)
opt_temp <- optim(par = opt_temp$par,
Fec = Fec,
N_F0 = N_F0,
N_Z_F = N_Z_F,
lower = c(1E-4,1E-4),
upper = c(NA,1-1E-5),
method = "L-BFGS-B",
fn = optimFunc, hessian = FALSE,
control = list(
maxit = 1000,
ndeps = rep(1e-4,2)))
## raw calc
# Recr <- c(0,0)
# for(i in 1:2){
#   Top <- 4*Steep[i]*SSB[i]/SBPF0[i] - (1-Steep[i])
#   Bot <- (5*Steep[i]-1)*SSB[i]/SBPF0[i]
#   Recr[i] <- max(1e-4,Top/Bot)
# }
#
# return(Recr)
## optimize
opt_temp <- optim(par = c(1,Prop),
Fec = Fec,
N_F0 = N_F0,
N_Z_F = N_Z_F,
lower = c(1E-4,1E-4),
upper = c(NA,1-1E-5),
method = "L-BFGS-B",
fn = optimFunc, hessian = FALSE,
control = list(
maxit = 1000,
ndeps = rep(1e-4,2)))
Prop = 0.5
## raw calc
# Recr <- c(0,0)
# for(i in 1:2){
#   Top <- 4*Steep[i]*SSB[i]/SBPF0[i] - (1-Steep[i])
#   Bot <- (5*Steep[i]-1)*SSB[i]/SBPF0[i]
#   Recr[i] <- max(1e-4,Top/Bot)
# }
#
# return(Recr)
## optimize
opt_temp <- optim(par = c(1,0.5),
Fec = Fec,
N_F0 = N_F0,
N_Z_F = N_Z_F,
lower = c(1E-4,1E-4),
upper = c(NA,1-1E-5),
method = "L-BFGS-B",
fn = optimFunc, hessian = FALSE,
control = list(
maxit = 1000,
ndeps = rep(1e-4,2)))
optimFunc <- function(par,Fec,N_F0,N_Z_F){
# cat(par,"\n")
cat(dat$h,"\n")
passR <- par[1]; passRprop <- par[2]
#print(passR)
#print(passRprop)
sb_F <- sb_0 <- Cat <- c(0,0)
PropF0 = dat$input_prop
RecF0 = GLOBAL_R0
Nages <- 20
for(area in 1:2){
for (Iage in 1:Nages) sb_0[area] <- sb_0[area] + RecF0*Fec[area,Iage]*(PropF0*N_F0[area,Iage,1]+(1-PropF0)*N_F0[area,Iage,2])
for (Iage in 1:Nages) sb_F[area] <- sb_F[area] + passR*Fec[area,Iage]*(passRprop*N_Z_F[area,Iage,1]+(1-passRprop)*N_Z_F[area,Iage,2])
}
Rexp = c(0,0)
for(i in 1:narea){
if(i == 1){
num <- GLOBAL_R0*passRprop*4*dat$h[i]*sb_F[[i]]/sb_0[[i]]
} else{
num <- GLOBAL_R0*(1-passRprop)*4*dat$h[i]*sb_F[[i]]/sb_0[[i]]
}
denom1 <- sb_F[[i]]/sb_0[[i]]*(5*dat$h[i]-1)
denom2 <- (1-dat$h[i])
Rexp[i] = num/(denom1+denom2)
} ## end area loop
obsR <- passR*c(passRprop,1-passRprop)
#cat(obsR,"\n")
#cat(Rexp,'\n')
obj <- sum((obsR - Rexp)^2)
#cat(passR,passRprop,obj,"\n")
return(obj)
}
getEqR <- function(assumption = 'GLOBAL', Fec, N_F0, N_Z_F, Prop, Steep){
if(assumption == 'GLOBAL'){
# use summed qtties and return straight up req
# Top <- 4*GLOBAL_R0*Steep*SSB/SBPF0 - (1-Steep)
# Bot <- (5*Steep-1)*SSB/SBPF0
# Recr <- Top/Bot
# return(max(1e-4,Recr))
cat(Steep,"\n")
SBPR <- SBPF0 <- Cat <- c(0,0)
Nages <- 20
for(area in 1:2){
for (Iage in 1:Nages) SBPF0[area] <- SBPF0[area] + Fec[area,Iage]*(Prop*N_F0[area,Iage,1]+(1-Prop)*N_F0[area,Iage,2])
for (Iage in 1:Nages) SBPR[area] <- SBPR[area] + Fec[area,Iage]*(Prop*N_Z_F[area,Iage,1]+(1-Prop)*N_Z_F[area,Iage,2])
}
SBPF0 <- sum(SBPF0)
SSB  <- sum(SBPR)
alpha = SBPF0*(1-Steep)/(4*Steep)
beta = (5*Steep-1)/(4*Steep*GLOBAL_R0)
req <- max(0.001, (SSB - alpha)/(beta*SSB)) ## a la SS
#cat("LocalR",req,"\n")
} else{
## raw calc
# Recr <- c(0,0)
# for(i in 1:2){
#   Top <- 4*Steep[i]*SSB[i]/SBPF0[i] - (1-Steep[i])
#   Bot <- (5*Steep[i]-1)*SSB[i]/SBPF0[i]
#   Recr[i] <- max(1e-4,Top/Bot)
# }
#
# return(Recr)
## optimize
opt_temp <- optim(par = c(1,0.5),
Fec = Fec,
N_F0 = N_F0,
N_Z_F = N_Z_F,
lower = c(1E-4,1E-4),
upper = c(NA,1-1E-5),
method = "L-BFGS-B",
fn = optimFunc, hessian = FALSE,
control = list(
maxit = 1000,
ndeps = rep(1e-4,2)))
opt_temp <- optim(par = opt_temp$par,
Fec = Fec,
N_F0 = N_F0,
N_Z_F = N_Z_F,
lower = c(1E-4,1E-4),
upper = c(NA,1-1E-5),
method = "L-BFGS-B",
fn = optimFunc, hessian = FALSE,
control = list(
maxit = 1000,
ndeps = rep(1e-4,2)))
return(opt_temp)
}
}
N_F0 <- doNAA(F1=0,F2=0, usedat =dat, Sel)$N
N_Z_F <- doNAA(F1, F2, usedat = dat, Sel)
## derived quants on a per-area basis
## these are per one recruit (no prop here)
SBPR <- SBPF0 <- Cat <- c(0,0)
Cat <- matrix(0,nrow=2,ncol=2)
for(area in 1:2){
for (Iage in 1:Nages) SBPF0[area] <- SBPF0[area] + Fec[area,Iage]*sum(N_F0[area,Iage,1:2])
for (Iage in 1:Nages) Cat[area,1] <- Cat[area,1] + WAA[area,Iage]*Sel[area,Iage]*c(F1,F2)[area]*sum(N_Z_F$N[area,Iage,1])/
N_Z_F$Z[area,Iage]*(1.0-exp(-N_Z_F$Z[area,Iage]))
for (Iage in 1:Nages) Cat[area,2] <- Cat[area,2] + WAA[area,Iage]*Sel[area,Iage]*c(F1,F2)[area]*sum(N_Z_F$N[area,Iage,2])/
N_Z_F$Z[area,Iage]*(1.0-exp(-N_Z_F$Z[area,Iage]))
for (Iage in 1:Nages) SBPR[area] <- SBPR[area] + Fec[area,Iage]*sum(N_Z_F$N[area,Iage,1:2]) ## does NOT have prop
}
req_global <- getEqR(assumption = 'GLOBAL',
Fec = Fec,
N_F0 = N_F0,
N_Z_F = N_Z_F$N,
Prop=dat$input_prop,
Steep = mean(dat$h))
dat$h
req_local <- getEqR(assumption = 'LOCAL',
Fec = Fec,
N_F0 = N_F0,
N_Z_F = N_Z_F$N,
Prop=dat$input_prop,
Steep = dat$h)
Recr_global = c(req_global*dat$input_prop,req_global*(1-dat$input_prop))
Recr_local <- c(req_local$par[1]*req_local$par[2],req_local$par[1]*(1-req_local$par[2]))
#print(Cat)
print(Recr_global)
print(Recr_local)
getEqR <- function(assumption = 'GLOBAL', Fec, N_F0, N_Z_F, Prop, Steep){
if(assumption == 'GLOBAL'){
# use summed qtties and return straight up req
# Top <- 4*GLOBAL_R0*Steep*SSB/SBPF0 - (1-Steep)
# Bot <- (5*Steep-1)*SSB/SBPF0
# Recr <- Top/Bot
# return(max(1e-4,Recr))
cat(Steep,"\n")
SBPR <- SBPF0 <- Cat <- c(0,0)
Nages <- 20
for(area in 1:2){
for (Iage in 1:Nages) SBPF0[area] <- SBPF0[area] + Fec[area,Iage]*(Prop*N_F0[area,Iage,1]+(1-Prop)*N_F0[area,Iage,2])
for (Iage in 1:Nages) SBPR[area] <- SBPR[area] + Fec[area,Iage]*(Prop*N_Z_F[area,Iage,1]+(1-Prop)*N_Z_F[area,Iage,2])
}
SBPF0 <- sum(SBPF0)
SSB  <- sum(SBPR)
alpha = SBPF0*(1-Steep)/(4*Steep)
beta = (5*Steep-1)/(4*Steep*GLOBAL_R0)
req <- max(0.001, (SSB - alpha)/(beta*SSB)) ## a la SS
#cat("LocalR",req,"\n")
} else{
## raw calc
# Recr <- c(0,0)
# for(i in 1:2){
#   Top <- 4*Steep[i]*SSB[i]/SBPF0[i] - (1-Steep[i])
#   Bot <- (5*Steep[i]-1)*SSB[i]/SBPF0[i]
#   Recr[i] <- max(1e-4,Top/Bot)
# }
#
# return(Recr)
## optimize
opt_temp <- optim(par = c(1,0.5),
Fec = Fec,
N_F0 = N_F0,
N_Z_F = N_Z_F,
lower = c(1E-4,1E-4),
upper = c(NA,1-1E-5),
method = "L-BFGS-B",
fn = optimFunc, hessian = FALSE,
control = list(
maxit = 1000,
ndeps = rep(1e-4,2)))
return(opt_temp)
}
}
